# 처리율 제한 장치의 설계
처리율 제한 장치란 클라이언트 또는 서비스가 보내는 트래픽의 처리율을 제어하기 위한 장치로서 요청에 대한 정해진 임계치를 넘어서면 추가로 도달되는 요청은 block된다.

## 1단계 문제 이해 및 설계 범위 확정
면접관과 소통하면서 구현해야할 제한 장치의 요구사항을 정리
- 클라이언트 측 or 서버 측 제한 장치인지
- API 호출 제한 기준
- 시스템의 규모
- 분산 환경에서의 동작 여부
- 서비스의 유무 (독립 or 애플리케이션에 의존적인지)
- 제한된 요청에 대한 확인 여부

## 2단계 개략적 설계안 제시 및 동의 구하기

### 처리율 제한 장치의 위치
제한 장치를 미들웨어로 하여금 api 서버로 가는 요청을 통제하도록 설계한다. 구현의 경우 서버 측 구현의 효율성을 검증하고 api gateway를 사용하는 경우엔 다른 사용자 인증이나 ip whitelist 관리를 위해 api gateway를 설계에 포함시켰다면 제한 기능 또한 포함시킨다.

### 처리율 제한 알고리즘
총 5가지 종류가 존재

#### 토큰 버킷 알고리즘
버킷이라고 하는 지정된 용량을 갖는 컨테이너로 토큰이 주기적으로 채워지는데 꽉 찼을 경우 공급된 토큰은 버리며 각 요청이 처리될 때마다 하나의 토큰을 사용한다. 이때 토큰이 없는 경우 해당 요청은 drop한다. 2개의 인자 (버킷 크기, 토큰 공급률)이 필요하다.

장점
- 구현이 쉽고 메모리 효율이 좋다
- 짧은 시간에 집중되는 트래픽도 처리 가능하다.

단점
- 두개의 인자를 적절히 튜닝하는게 어렵다

#### 누출 버킷 알고리즘
토큰 버킷과 비슷하지만 요청 처리율이 고정되었다는 점에서 다르다. 보통 FIFO 큐로 구현한다. 마찬가지로 2가지의 인자가 필요하다.(버킷 크기, 처리율)

장점
- 큐의 크기가 제한되어 메모리 사용량 측면에서 효율적
- 고정된 처리율을 지녀서 안정된 출력이 필요한 경우 적합

단점
- 짧은 시간에 트래픽이 몰릴 경우 많은 요청들이 버려지게 된다
- 두개의 인자 튜닝이 까다롭다

#### 고정 윈도 카운터 알고리즘
타임라인을 고정된 윈도우로 나누고 각 윈도우마다 카운터를 붙인다. 요청이 접수될 때마다 카운터의 값은 1씩 증가하게 되고 카운터의 값이 사전에 정의된 임계치를 넘어가면 새로운 요청은 버린다.

장점
- 메모리 효율이 좋고 이해가 쉽다
- 특정한 트래픽 패턴 처리에 적합하다

단점
- 윈도 경계 부근에서 일시적으로 많은 트래픽이 몰릴 경우 시스템의 처리 한도보다 많은 양의 요청을 처리하게 된다

#### 이동 윈도 로깅 알고리즘
고정 윈도 카운터의 단점을 해결한 알고리즘이다. 이 알고리즘은 요청의 타임스탬프를 추적해서 보통 레디스의 정렬 집합 같은 캐시에 보관한다. 새 요청의 타임스탬프를 로그에 추가하고 로그의 크기가 허용치보다 같거나 작으면 시스템에 전달하고 아니면 버린다.

장점
- 알고리즘이 구현하는 처리율 제한 메커니즘이 매우 정교하다
  
단점
- 요청이 거부된 타임스탬프도 보관해서 다량의 메모리를 사용한다

#### 이동 윈도 카운터 알고리즘
고정 윈도 카운터와 이동 윈도 로깅을 합친 알고리즘이다. 

장점
- 이전 시간대의 평균 처리율에 따라 현재 윈도의 상태를 계산하므로 짧은 시간에 몰리는 트래픽에 잘 대응한다
- 메모리 효율이 좋다

단점
- 직전 시간대에 도착한 요청이 균등하다고 가정하고 추정치를 계산하기 떄문에 다소 느슨하다.

### 개략적인 아키텍쳐
클라이언트가 요청을 보낼 시 처리율 제한 미들웨어를 통해 해당 요청을 거부할지 결정하고 처리율을 제한할지 결정하는 알고리즘의 카운터 같은 값들은 레디스에 저장한다. 한도에 도달하지 않은 경우엔 api 서버로 요청을 전달한다.

## 3단계 상세 설계

### 처리율 초과 트래픽 처리 및 제한 규칙
처리율 제한 규칙의 경우엔 config 파일 형태로 만들어 디스크에 저장한다. 또한, 한도 초과된 트래픽의 처리의 경우 요청을 버리거나 메시지 큐에 보관하여 나중에 처리하도록 한다. 이때 클라이언트가 요청이 제한되었다는 것을 알리기 위해 HTTP 응답 헤더에 X-Ratelimit-Retry-After를 429 code와 함께 반환하도록 한다.
### 분산 환경에서의 처리율 제한 장치 구현
분산 환경의 경우 race condition과 synchronization 문제를 해결해야한다.

#### 경쟁 조건
경쟁 조건의 경우 lock을 써서 선점하는게 일반적이지만 시스템의 성능이 떨어지기 때문에 Lua script를 이용하거나 redis의 sorted set을 이용해서 해결한다.

#### 동기화 이슈
sticky session을 활용하여 같은 클라이언트는 항상 같은 처리율 장치로 보낼 수 있지만 이 방법은 규모 확장성 측면에서 비효율적이기 때문에 레디스와 같은 중앙 집중형 데이터 저장소를 이용한다.

#### 성능 최적화
데이터센터의 경우 여러 곳에 분산되어 있기 때문에 사용자의 요청을 엣지 서버를 이용해서 latency를 최대한 줄인다. 그리고 제한 장치 간에 데이터를 동기화할 때 최종 일관성 모델을 사용한다.

#### 모니터링
처리율 제한 장치의 알고리즘과 규칙이 효율적인지 확인하기 위해서 모니터링을 하고 모니터링에 따라 규칙이나 알고리즘을 수정하도록 한다.

## 4단계 마무리
HTTP 요청을 다루는 7단계 계층인 애플리케이션 뿐만 아니라 IP주소에 따라 요청을 제한하는 3계층 처리율 제한도 적용이 가능하다는 점도 이용한다. 그리고 처리율 제한을 회피하기 위한 클라이언트 측에서의 설계도 중요하다. retry나 예외적 상황으로부터 복구 등 최대한 잘 설계하도록 한다.