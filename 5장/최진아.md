# 5장_안정 해시 설계

<aside>
💡 수평적 규모 확장성을 달성하려면, 요청/데이터를 서버에 균등하게 나누는 것 중요
이 때, 안정 해시 기술 사용

</aside>

# 해시 기술이 풀려고 하는 문제

## rehash문제

N개의 캐시 서버가 있을 때, 각각의 키의 해시값을 이용하여 서버 인덱스 값을 구함. 이를 통해 서버들에 부하를 균등하게 나누고자 함. 

(그림5-1)

잘 작동되는 경우

- server pool의 크기가 고정되어 있을 때
- 데이터 분포가 균등할 때

문제가 생기는 경우

- 서버가 추가 될 때
- 기존 서버가 삭제될 때
    - 서버가 1개 삭제되면, 위의 그림에서 hash % 4 → hash % 3으로 바뀜
    - 대부분의 캐시 클라이언트가 데이터가 없는 엉뚱한 서버에 접속하게 됌 → **대규모 cache miss 발생**

# 안정 해시

: 해시 테이블 크기가 조정될 때 평균적으로 오직 k/n개의 키만 재배치하는 해시 기술

( k : 키의 개수, n : 슬롯의 개수) 

(반면, 전통적 해시 테이블은 슬롯 수가 바뀌면 대부분의 키를 재배치 함)

장점

- 서버가 추가되거나 삭제될 때 재배되는 키의 수 최소화
- 데이터가 보다 균등하게 분포되므로 수평적 규모의 확장성을 달성하기 쉬움
- 데이터가 보다 균등하게 분포되므로 hotspot 키 문제를 줄임
    - 특정 shard에 대한 접근이 지나게 빈번하면 서버 과부하 문제 생길 수 있음

## 해시 공간 & 해시 링

해시 함수 f = SHA-1

SHA-1 의 hash space : 0~ 2^160-1

해시 함수의 출력 값 : x0, x1, … , xn (출력 값의 범위 = SHA-1의 hash space)

(그림 5-4)

## 해시 서버

서버를 해시 링 위에 배치

(그림 5-5)

## 해시 키

캐시할 키 또한 해시 링 위에 배치

(그림 5-6)

## 서버 조회

특정 키가 저장되는 서버 = 해당 키의 위치로부터 시계 방향으로 링을 탐색했을 때 가장 처음 만나는 서버

(그림 5-7)

## 서버 추가

안정 해시 기술을 사용하면, 그림처럼 서버 s4를 추가하면 키 k0만 재배치 되고, 나머지는 그대로 있음(서버 조회 방식 참고)

(그림 5-6)

## 서버 제거

안정 해시 기술을 사용하면, 그림처럼 서버 s1을 제거 했을 때, 키 k1만 서버 s2로 재배치 됌 (서버 죄회 방식 참고)

(그림 5-9)

# 안정 해시 알고리즘 기본 구현법의 2가지 문제

안정 해시 알고리즘 기본 구현법

1. 서버와 키를 uniform distribution 해시 함수를 사용해 해시 링에 배치한다
2. 키의 위치를 링을 시계 방향으로 탐색하다 만나는 최초의 서버가 키가 저장될 서버다

문제

1. 서버가 추가/삭제되는 상황에서 partition의 크기를 균등하게 유지하는 게 불가능하다
    
    : 어떤 서버는 큰 해시 공간을 할당받고, 어떤 서버는 작은 해시 공간을 할당 받음
    
    `partition` : 인접한 서버 사이의 해시 공간
    
2. 키의 uniform distribution을 달성하기 어렵다
    - 대부분의 키는 서버 2에 보관 될 것 (그림 5-11)
    - 해결 방법 : [virtual node (replica)](https://www.notion.so/5-_-a9edf6d6c3054ab2ad96a06e94e78b6a?pvs=21)

## 해결방법

### 가상 노드

: 실제 노드/서버를 가리키는 노드로, 하나의 서버는 링 위에 여러 개의 가상 노드를 가질 수 있다

(그림 5-12)

각 서버는 여러개의 파티션을 관리해야 함

- 가상노드의 수를 늘리면 키의 분포는 더 균등해짐 (std가 작아져서 데이터가 고르게 분포되기 때문), 하지만 가상노드 데이터를 저장할 공간 더 필요해짐 (trade-off)
