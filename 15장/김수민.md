# 구글 드라이브 설계

## 1단계 문제 이해 및 설계 범위 확정
- 중요하게 지원해야할 기능들은 무엇인지
- 지원해야 할 클라이언트의 범위
- 파일에 대한 암호화
- 파일 크기 제한
- 사용자의 수
  
## 2단계 개략적 설계안 제시 및 동의 구하기
해당 시스템은 기본적으로 세 가지 API 가 필요하다.
1. 파일 업로드
2. 파일 다운로드
3. 파일 갱신 히스토리

### 한 대 서버의 제약 극복
저장소르 아마존 S3를 사용하여 확장성 가용성을 확보한다.

### 개략적 설계안
- 사용자 단말
- 블록 저장소 서버
- 클라우드 저장소
- 아카이빙 저장소
- 메타데이터 캐시
- 메타데이터 데이터베이스
- API 서버
- 로드밸런서
- 오프라인 사용자 백업 큐

## 3단계 상세 설계

### 블록 저장소 서버
큰 파일들은 업데이트가 일어날 때ㅔ마다 전체 파일을 보내면 네트워크 대역폭을 많이 잡아먹게 된다. 최적화하는 방법은 아래와 같다.
- 델타 동기화
- 압축

### 높은 일관성 요구사항
관계형 DB의 경우 ACID를 보장하므로 강한 일관성을 쉽지만 NoSQL은 그렇지 못하므로 동기화 로직 안에 프로그램해 넣어야 한다.

### 업로드 절차
사용자는 두개의 요청을 병렬적으로 보내 업로드를 요청한다
- 파일 메타데이터 추가
- 파일을 클라우드 저장소에 업로드

### 다운로드 절차
파일 다운로드는 파일이 새로 추가되거나 편집되면 자동으로 시작된다.
시작된다는 사실은 변경 알림을 통해 알게 된다.

### 알림 서비스
파일의 일관성을 유지하기 위해 클라이언트는 로컬에서 파일이 수정되었음을 감지하는 순간 다른 클라이언트에 그 사실을 알려서 충돌 가능성을 줄여야 한다
크게 두 가지 방식이 있으며 롱 폴링을 사용한다.
- 롱 폴링
- 웹소켓

그 이유는 채팅과 달리 양방향 통신이 필요하지 않기 때문이다.

### 저장소 공간 절약
- 중복 제거
- 지능적 백업 전략
  - 한도 설정
  - 중요한 버전만 보관
- 자주 안ㅆ느느 데이터 아카이빙 저장소로 이동

### 장애 처리
- 로드밸런서 장애
- 블록 저장소 서버 장애
- 클라우드 저장소 장애
- API 서버 장애
- 메타데이터 캐시 장애
- 메타데이터 데이터베이스 장애
- 알림 서비스 장애
- 오프라인 사용자 백업 큐 장애

## 4단계 마무리
추가적으로 생각해야할 부분
- 설계안에 다른 선택지에 대한 고민
- 접속 상태를 관리하는 로직