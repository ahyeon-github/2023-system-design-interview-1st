# 12장_채팅 시스템 설계

### 채팅 앱 종류

- 1:1
- 그룹
- 음성

### 기본 지식

- 클라이언트 끼리 통신x
- 클라이언트는 채팅 서버와 통신

## 제공 기능

### 클라이언트들로부터 메시지 수신

- 클라이언트
    - 채팅 서비스에 HTTP 프로토콜로 연결, 메시지를 보내어 수신자에게 해당 메시지를 전달하라고 알림
    - 접속 시, keep-alive 헤더 사용 (연결을 유지할 수 있음)
- 클라이언트로 임의 시점에 메시지 보내기
    - 서버가 연결을 만드는 것처럼 동작할 수 있도록 하는 기법
        - polling
            - 클라이언트가 주기적으로 서버에게 새 메시지가 있냐고 물어보는 방법
            - 단점 : 답해줄 메시지가 없을 경우, 서버 자원 낭비
        - long polling
            - 클라이언트가 서버에게 새 메시지가 있냐고 물어보고, 타임아웃이 되거나 새 메시지가 반환될때까지 연결 유지 (주기적으로 물어보는게 아님 → polling 단점 보완)
            - 단점
                - 서버는 클라이언트가 연결을 해제했는지 알 수 없음
                - 메시지를 받은 서버가 메시지를 수신할 서버와 long polling 연결을 가지고 있지 않은 서버일 수 있음
                - 타임아웃이 일어날때마다 다시 서버 접속 → 비효율적
        - websocket
            - 서버가 클라이언트에게 비동기 메시지를 보낼때 주로 사용
            - 한번 연결되면 오래감.
            - 메시지 양방향 전송.

### 메시지 수신자 결정 및 전달

### 수신자가 접속 상태가 아닌 경우, 접속할 때까지 해당 메시지 보관

## 채팅 시스템

### 무상태 서비스

- 로드밸런서 뒤에 위치
- 요청/응답 서비스
    - monolithic 서비스, 마이크로서비스, 서비스 탐색 서비스 등…
    - 서비스 탐색 서비스
        - 사용 가능한 모든 채팅 서버를 등록시켜두고, 클라이언트가 접속 시도하면 사전에 정한 기준에 따라 최적의 채팅 서버의 DNS 호스트명을 클라이언트에게 알려줌
            - 추천 기준
                - 클라이언트의 위치 (geo)
                - 서버의 용량
            - 구현 시 사용하는 오픈 소스 : Apache Zookeeper 등

### 상태유지(stateful) 서비스

- 채팅 서비스
- 각 클라이언트가 채팅 서버와 독립적인 네트워크 연결을 유지
- 채팅 서비스와 서비스 탐색 서비스의 협력 → 특정 서버에 부하가 몰리지 않도록 함

### 제3자 서비스 연동

- 제3자 서비스 : 푸시알림 서비스

### 규모 확장성

- 서버 여러대 사용
- 그림 12-7과 12-8의 연결
- 채팅 서버 : 클라이언트 사이에 메시지를 중계하는 역할
- 접속상태 서버 : 사용자의 접속 여부 관리
- API 서버 : 로그인, 회원가입 등 나머지 전부 처리
- 알림서버 : 푸시 알림 보내기
- 키-값 저장소 : 채팅 history 보관

### 저장소

보관할 것 

- 사용자 프로필, 설정, 친구 목록 등 → 일반적인 데이터
    - 다중화, sharding 적용 → 데이터의 가용성, 규모확장성 보증
- 채팅 history
    - 최근에 주고받은 메시지가 가장 빈번하게 사용됌
    - 1:1 채팅앱의 경우, 읽기:쓰기 비율= 1:1

보관할 곳

- 키-값 저장소
    - 채팅 시스템에 주로 사용 (페이스북→ HBase, 디스코드→Cassandra)
    - 장점
        - 수평적 규모 확장 용이
        - 데이터 접근 지연시간이 낮음
        - 관계형 DB는 데이터의 long tail 부분을 잘 처리하지 못함

### 접속 장애

- 웹소켓 연결이 끊어질 경우
    - heartbeat 검사 방법으로 해결
        - 온라인 상태의 클라이언트가 주기적으로 hearbeat event를 접속상태 서버에 보냄
        - 마지막 event를 받은지 x초 이내에 또 다른 heartbeat event를 받으면, 해당 사용자의 접속상태를 계속 온라인으로 유지 (아닐경우 오프라인으로 변경)
